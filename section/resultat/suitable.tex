\section{Suitable evaluation test}
\subsection{Purpose}




%Anledningen till att vi vill göra detta test är att se om det är möjligt att använda sig av ICNs pull strategi för att hämta data kontinuerligt från en sensor. Det vore intressant att se om det är möjligt att skapa ett system där användaren får datat så fort det har skapats hos sensorn, där tiden det tar från att datat har skapats tills dess att användaren har det är så liten som möjligt. Vanligtvis användes diverse publish subscribe system som t.ex MQTT för att erhålla datat så snabbt som möjligt som användare. Där pushas datat ut från sensorn då det tillverkats. Istället för denna push model, är det av intresse att utvärdera ICNs pull strategi tillsammans med `one-time subscription'-modellen som Ahlgren et al beskriver i [ref.]. Resultatet visar om det är möjligt att combinera de två tänken för att erhålla datat så snabbt som möjligt samt hur stabilt ett sådant system skulle kunna tänkas vara.  

%The result show if such a possibility exists with data produced with a constant interval over a long period of time. 
%The communication patterns of ICN and CCN is by natural pull-based, which is in contradiction to a regular publish/subscribe protocol such as MQTT. When using a publish/subscribe communication protocol, it can send the newly produced data directly towards a consumer. 

%With the CCN possibility of storing \textit{interest} requests at the sensors, combined with the `one-time' subscription approach described by Ahlgrens et al[ref], it could be possible to achive the same functionallity with ICN. It is interesting to see how such a combination would perform over time. 

%%
%The reason to do this experiement is to see if it is possible to use the ICNs pull strategy to retrieve data continuously from a sensor. 

%\begin{itemize}
%\item retreieve data ass soon as it has been possible.
%\item one time subscription
%\item long time interval
%\item Follow sequence and periodicity from sensor
%\item The interval time between the data created by the sensor is known beforehand from the requestor.
%\item refer to MQTT difference
%\item CCN.
%\end{itemize}

The purpose of this experiment is to create a suitable software for a consumer that follows an interval and retrieves the data created periodically by a sensor node. The consumer should be able to recieve the data as soon as it has been created at the sensor. This should be possible over a interval with arbitrary length and the data is produced at a periodic interval. Usually a publish subscribe communication such as MQTT handle this by pushing the data towards the consumer when the data is created. 
With the CCN possibility of storing \textit{interest} requests at the sensors combined with the `one-time' subscription approach, described by Ahlgrens et al in \cite{Ahlgreniot} where the consumer sends an \textit{interest} in advance for future data, it could be possible to achive the same functionallity with ICN. The results show how such an system would perform over time and if it is a feasible replacement to the publish subscribe approach. 

Although the purpose is to follow the sequence numbering of the data, it is out of the scope of this thesis to find the latest sequence number. This is considered to be known for the system in advance.
%\subsection{Delim}
%It is not a purpose to find the latest sequence number, this is given at first hand. There are several different types of techniques to get the latest sequence number, but it is out of scope of this paper. 
\subsection{Method}
Develop software

\begin{itemize}
\item Follow interval on sensor, becomes a problem due to the fact that there is two different clocks. One on sensor that is producing at a certain interval speed, and one at the client that wants to consume at a regular interval speed.
\item Come to the right sensor
\item First timeout, usage of PIT, one time subscription model. Describe the one time subscription model.
\item After timeout, Algoritm usage to follow/correct
\item The algoritm.\\
\end{itemize}

\begin{itemize}
\item Algorithm
\end{itemize}
The algorithm, shown in figure \ref{fig:onetime}, developed in this project is a first attempt to retreive the data with a one time subscription approach described earlier. 
The algorithm tries to fetch data at a certain interval in order to recieve the data as soon as it has been created on the sensor. It calculates when to send the next request, towards the sensor, based on the round trip time of the current interval. It borrows the smoothed round trip time (srtt) technic from TCP, which makes the system more tolerent if one latency value is varying a lot from the normal. One must set a round trip target (rtt$\_$target) that the algortihm should try to follow, the target should be a factor of the minimum round trip time (rtt$\_$min). In the algortihm, there is a background correction factor that has to be calculated at every interval. This correction time is the difference between the srtt and the rtt$\_$target, and represent the difference in time between the two systems. It is added to the time it should send the next request, together with the interval time of the periodicity.\\\\
\begin{itemize}
\item diff rttmin rtt$\_$target
\end{itemize}
When using the pit, one can not retrieve the same latency times as in the previous measurement where the data was replied directly upon request. Instead, one must set a round trip target that is related to the minimum round trip time. The difference between rtt$\_$target and rtt$\_$min defines how large the time span is that we can regulate. The smaller differences, the more vulnerable the system becomes for variations of rtt. The minimum difference must be greater than the differences between the two intervals between the sensor and the gateway, if it gets less the algortihm stops working properly.

The reason of using the rtt$\_$target is that we want to send the \textit{interest} request at a confortable distance before the data has been created.
Instead, the request must be initiated before the\\\\
\begin{itemize}
\item Smoothed RTT
\end{itemize}
In order to calculate when to send the next request towards the sensor, one could use the rtt and subtract it from the interval. 
However, this makes the system more sensitive to changes in the latencies which could lead to timeouts for a consumer. To solve this and make the latencies more stable over time, the smoothed rtt is used in the algortihm. It uses a factor, $\alpha$, to decide how the current value should be weighted in comparison to the previous values. The greater $\alpha$ becomes, the less importance the older values has and vice versa when $\alpha$ becomes smaller, the importance of older values grows.
If the latencies of the srtt is high, then the \textit{interest} request is sent to early towards the sensor. At the same time, if the srtt latency becomes to short, then the request are sent to late.\\\\
\begin{itemize}
\item Corr \\
	The difference in clock time between the sensor and the gw is measured with corr.
\end{itemize}

   
\begin{figure}
\begin{algorithm}[H]
 next = reference time\;
 rtt$\_$min\;
 rtt$\_$target = rtt$\_$min * \textit{x}\;
 $\alpha$ = 0 <= $\alpha$ <= 1\;
 \While{infinity}{
  rtt = send$\_$interest$\_$receive$\_$data\;
  \If{not timeout}{
   srtt = $\alpha$ $\times$ rtt + ($\alpha$ - 1) $\times$  srtt\;
   corr = srtt - rtt$\_$target\;
   }
   next$\_$time = next$\_$time + interval$\_$time + corr\;
   sleep(next$\_$time - current$\_$time)\;
 }

\end{algorithm}
\caption{Algorithm that makes it possible for a consumer to follow the creation of data with a certain interval.}
    \label{fig:onetime}
\end{figure}


\subsection{Result}
Suitable.

\begin{itemize}
\item Show that the algorithm can follow the interval and period over time. (show this with standard case 0.1 first.)\\
\end{itemize}
The results regarding latencies when using $\alpha$ = 0.1 and \textit{rtt$\_$target} = 2.5 is shown in figure[0.1], where the interval sequence number is shown on the x-axis and the roundtrip latency is shown on the y-axis. The same axis layout holds for figures[all figures], all of which regards the round trip times from the consumers perspective. 
The results, illustrated in figure [fig], shows that the latency is stable between 90-100 ms, the srtt is stable with a small varians around 95 ms and that the corr factor is stable around 5 ms aswell. This results indicate that the consumer can retrieve the data in a stable manner.\\\\
The corresponding time from a sensors perspective is shown in figures [show all figures], where the interval sequence number is shown on the x-axis and the age of the data is shown on the y-axis. Since the sensor is making use of the PIT, the y-axis show the time between it recieved the \textit{interest} til the \textit{data} was created and responded towards the requestor. Figure [0.1] show that the age of the \textit{interest} is very stable at 62 ms (8 tick). The movement few movements up and down has to do with 
[Write about that this is indicating that it works!]


\begin{itemize}
\item Show difference between using $\alpha$ = 0.1, 0.9 and 1.
\end{itemize}
When $\alpha$ is changed to 0.9, the resulting curves, illustrated in figure [gw0.9] and [s0.9], shows an more alternating form. It alternates between values from 87 ms up to 117 ms in latency and the age of the \textit{interests} at the sensor is pending between 56 ms and 70 ms. This is due to the fact that the srtt has less importance and influence as $\alpha$ grows, and the time when next \textit{interest} is sent is more dependent on the latency time of the previous one. 
When $\alpha$ is set to 1, illustrated in figure [gw1] and [s1], the latency times alternate between 87 ms and 117 ms as well as in $\alpha$ = 0.9, but here the frequency is greater. In this case, the smoothing is not available and therefore the correction is only dependent on the last roundtrip time. 



\subsubsection{Different intervals}
\begin{itemize}
\item Show that it can handle diff in the interval. The producer has a different interval than the consumer. Works great without problems for positive changes, where the producer is creating the data at a slower interval, say 1.2 second per data.
\item Show difference in time. 
\end{itemize}
All of the previous results was made under the assumption that the two intervals are relative the same, one interval second on the sensor is almost the same as one interval second on the GW. To illustrate the functionallity when the sensor is providing data at different periodicity than the GW, other tests has been made.\\\\
In figure [gwdrift + 2$\%$] and [sdrift + 2$\%$], the sensor is creating the data with an interval of one second + 2$\%$ and the gw still use an interval period of one second. 
The results shows that the system is still stable over time, even though here is a positive drift in time on the sensor. The time it takes for an \textit{interest} to be consumed by the sensor is around 78 ms. The latency from the gw is overall higher, 105 ms to 125 ms, in comparission to without any difference in the time intervals, but the variation of srtt is still small and at the same levels. This is logic since the \textit{interest} is sent earlier from the GW towards the sensor, but at the the same intervals due to the algorithm. There is a cap though, when the \textit{interests} starts to timeout, the system will stop working properly and no data will be received at the gw. The drift on the sensor can not be greater, compared to the gw, than the timeout that the gw is setting on the \textit{interest}-packet when they are issued. Furthermore, the srtt is always greater than rtt$\_$target which provide stability in the system.
\begin{itemize}
	\item show diff in time negative, shorter time.
\end{itemize}
The system keeps beeing stable although the sensor period interval is less, -2$\%$, compared to the interval of the gw. The roundtrips are shorter than when the two intervals are the same and the age of the \textit{interests} are smaller too. The majority of the latencies is between 65 to 75 ms, as seen in figure [gw98], and the time it took to consumed the interest was around 40 ms as seen in figure [s98]. The reason why this is still stable is because the difference between rtt$\_$target and rtt$\_$min, 88 ms - 38 ms = 50 ms, is greater than the negative drift of -2 $\%$, approximatly 23 ms, of the sensors interval clock. Once the drift is greater than the difference between rtt$\_$min and rtt$\_$target, the system becomes unstable.






